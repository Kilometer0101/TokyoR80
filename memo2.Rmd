---
title: "初めてのreticulate"
author: "km"
date: "`r Sys.Date()`"
output: 
  html_document: 
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reticulate)
```

##### [Python環境構築](memo.html)→初めてのreticulate(ｲﾏｺｺ)

## 要件

**reticulate**パッケージを使ってR上でPythonを使う。

## Python側の準備

[環境構築](memo.html)を参照。

`Pipenv`で作った仮想環境が入ったフォルダに移動し、インタープリタのpathを確認。

```{bash, eval = F}
cd <hoge>/project   # 移動
pipenv shell        # 環境に入る
pipenv --venv       # pathを確認
```

Macでは`<hoe>/project/.venv`となる。

インタープリタのアドレスは`<hoe>/project/.venv/bin/python`となる。

仮想環境中にインストールされているパッケージを確認。

```{bash, eval =F}
pipenv run pip freeze
```

ここに**numpyがある**ことが必須。

ない場合は、インストールしておく。

```{bash, eval = F}
pipenv install numpy
```

proxy下なら、install前にshellした状態でpathを通しておく。
```{bash, eval = F}
export HTTP_PROXY=http://my-proxy-server:port
export HTTPS_PROXY=http://my-proxy-server:port
```

## R側の準備

パッケージのインストール

```{r, eval = F}
install.packages("tidyverse")   # 初心者は黙って入れよう 上級者はお好きに
install.packages("reticulate")  # R上でPythonを呼び出すインターフェース
```

インストールされているパッケージにattach

```{r, eval = F}
library(tidyverse)
library(reticulate)
```

## reticulateことはじめ

#### pathを通して仮想環境を呼び出す。

使いたいPythonインタープリタのpathを変数に取っておいて呼び出す。

```{r, include=F}
python_env <- "/Users/km/python/test/.venv/bin/python"

use_python(python = python_env, required = TRUE)
```

```{r, eval=F}
python_env <- "<hoge>/project/.venv/bin/python"

use_python(python = python_env, required = TRUE)
```


確認。


```{r, eval = F}
py_config()
```

こんな感じの出力になる(はず)。

```{eval = F}
## python:         <hoge>/project/.venv/bin/python
## libpython:      /Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/config-3.7...
## pythonhome:     /Library/Frameworks/Python.framework/Versions/3.7:/Library/...
## virtualenv:     <hoge>/project/.venv/bin/activate_this.py
## version:        3.7.4 (v3.7.4:e09359112e, Jul  8 2019, 14:36:03) ...
## numpy:         <hoge>/project/.venv/lib/python3.7/site-packages/numpy
## numpy_version:  1.16.4
## 
## NOTE: Python version was forced by use_python function
```

**注意**： 一度、Pythonのインタプリタを読み込むと、そのセッションでは異なるインタプリタを上書きして指定することはできない。切り替えたい場合はRを再起動(`command + shift + 0`)するなどして、セッションをリフレッシュする必要がある。

また、インタープリタの読み込みにはAnacondaに対応した`use_condaenv`や、virturalenvに対応した`use_virtualenv`という専用の関数があるが、ここでは推奨しない（Piperを使っていれば不要）。

#### Pythonで定義した関数をR上で使う


Python側で定義した関数を`./python/sample.py`に入れておく。\
(最近のRstudioではFile > NewFileからPython Scriptを選べる)

例えば下記。

```{python, eval = F}
import pandas as pd

def pd_load_csv(path):
  df = pd.read_csv(path)
  return df
  
def pd_head3(df):
  return df.head(3)

def pd_head(df, n = 3):
  return df.head(n)
```

これを使ってデータを変形してみる。

適当なcsvを作っておいて、

```{r, eval =F}
set.seed(71)
N <- 15
data.frame(x = 1:N,
           y = rnorm(N),
           z = sample(letters[1:3], N, replace = TRUE)) %>% 
  write.csv("data/sample1.csv", row.names = F)
```

PythonScript上で定義した関数を使って読み込む。

```{r}
source_python("python/sample.py")

path <- "data/sample1.csv" 

path %>% 
  pd_load_csv() %>% 
  pd_head3()
```

できた！

#### 注意点


ところが、どっこい、これ↓がエラーになる。

```{r, eval = F}
path %>% 
  pd_load_csv() %>% 
  pd_head(3)
```

>  py_call_impl(callable, dots$args, dots$keywords) でエラー: 
  TypeError: cannot do slice indexing on <class 'pandas.core.indexes.range.RangeIndex'> with these indexers [3.0] of <class 'float'> 
  
何やら`[3.0]`の`<vlass float>`で怒られていそうだ。そうかそうか、

```{r, eval = F}
path %>% 
  pd_load_csv() %>% 
  pd_head(3L)
```

これ(整数型指定)で動く。

Rではヨシナにしてくれている変数の型をちゃんとしないとPythonで動かないことがありますよというヤツ。

#### R上でPythonのパッケージを読み込んで使う

例えば、こんな事もできます。

```{r}
pd <- import("pandas")

pd$array(1:4)
```

これは`pandas`ライブラリで定義された関数をR上で使っています。\
ただ、`pandas`だと実際には読み込んだdata.frame名を使って、`df.head(n)`といった書き方をするので`pd$function`が使いやすい場面はあまりありません。

#### opencvを使ってみる

別の例ですが、opencv-python(`cv2`)を使って、画像の呼び出し・書き込みを行えます。Rの画像処理パッケージ三銃士（`magick`, `EBImage`, `imager`)を使った読み書きの実行時間を調べると...

```{r, eval = F}
library(magick)
library(EBImage)
library(imager)
cv2 <- import("cv2")

path_in <- "./fig/chunk.png"
path_out <- "./fig/chunk1.png"

```

```{r, include=F}
library(magick)
library(EBImage)
library(imager)
library(opencv)
cv2 <- import("cv2")

path_in <- "./fig/chunk.png"
path_out <- "./fig/chunk1.png"
```

```{r, eval = F}
## OpenCV
img <- cv2$imread(path_in)
cv2$imwrite(path_out, img)
```

```{r, eval=T, echo = F}
system.time({
  img <- cv2$imread(path_in)
  cv2$imwrite(path_out, img)
})
```

```{r, eval = F}
## magick
img <- image_read(path_in)
image_write(img, path_out)
```

```{r, eval=T, echo = F}
system.time({
  img <- image_read(path_in)
  image_write(img, path_out)
})
```

```{r, eval = F}
## EBImage
img <- readImage(path_in)
writeImage(img, path_out)
```

```{r, echo=F}
system.time({
  img <- readImage(path_in)
  writeImage(img, path_out)
})
```

```{r, eval = F}
## imager
img <- load.image(path_in)
save.image(img, path_out)
```

```{r, echo=F}
system.time({
  img <- load.image(path_in)
  save.image(img, path_out)
})
```

`cv2`が一番早い。（cv2 > magick > EBImage > imager）

ちなみに、Rからもopencvを使うパッケージ`opencv`があって、それも含めてちゃんと比べるとこうなる。

```{r}
library(microbenchmark)
library(opencv)

f_cv2 <- function(path_in, path_out){
  img <- cv2$imread(path_in)
  cv2$imwrite(path_out, img)
}

f_ocv <- function(path_in, path_out){
  img <- ocv_read(path_in)
  ocv_write(img, path_out)
}

f_magick <- function(path_in, path_out){
  img <- image_read(path_in)
  image_write(img, path_out)
}

f_EBImage <- function(path_in, path_out){
  img <- readImage(path_in)
  writeImage(img, path_out)
}

f_imager <- function(path_in, path_out){
  img <- load.image(path_in)
  save.image(img, path_out)
}

mbm <- microbenchmark(
  r_ocv = f_ocv(path_in, path_out),
  reticulate_cv2 = f_cv2(path_in, path_out),
  magick = f_magick(path_in, path_out),
  EBimage = f_EBImage(path_in, path_out),
  imager = f_imager(path_in, path_out))
```

```{r, echo=F, warning=F, message=F}
mbm
autoplot(mbm)
```

結果：opencvパッケージのほうが早かったですね...。

ちなみに直接Pythonでベンチマークをとるのはこんな感じで、

```{python, eval = FALSE}
import cv2
import time
import numpy as np

result = []
for i in range(0, 100):
  start = time.time()
  img = cv2.imread(r.path_in)
  cv2.imwrite(r.path_out, img)
  time_i = time.time() - start
  result = [result, time_i]
```

```{python, include = FALSE}
import cv2
import time
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns

result = []
for i in range(0, 100):
  start = time.time()
  img = cv2.imread(r.path_in)
  cv2.imwrite(r.path_out, img)
  time_i = np.array([time.time() - start])
  
  result = np.hstack((result, time_i))
```

これを含めて比べてみると、こうなる。

```{r, echo = F}
pyenv <- import_main()
pyenv$result %>% data.frame(expr = "py_ocv", time = .) %>%
  rbind(mbm %>% data.frame %>% mutate(time = time/10^9)) %>% 
  ggplot(aes(expr, log10(time)))+
  geom_violin()+
  theme(axis.title.y = element_blank())+
  ylab("log(time[sec])")+
  coord_flip()
```

pythonからopencv打った方がRのopencv pkgよりちょっとだけ早いけどほぼ同等。

#### Rmdで直にPythonを打つ

↑の図を作るには、

・ Rmd内でpythonを動かす\
・ python環境で求めた`result`をR環境から読み込む

という仕様が必要。

どうやってるかというと、まずpythonチャンクを作る。

Rmarkdownを作って、下記を実行すると...

````
`r ''````{r}
library(reticulate)

python_env <- "<hoge>/project/.venv/bin/python"
use_python(python = python_env, required = TRUE)
`r ''````

`r ''````{python}
df = pd.read_csv("data/sample1.csv")

df
`r ''````
````

```{python, echo = F}
df=pd.read_csv("data/sample1.csv" )
df.head(3)
```

動きます。

 この時呼ばれるのは、`py_config()`に出てくる環境(`use_python`で指定したもの)。

別のチャンクで先ほど定義したpandas dataframeの`df`をそのまま呼び出せます。

````
`r ''````{python}
df.sort_values(by = "z")
`r ''````
````

```{python, echo=F}
df.sort_values(by ='z')
```

それどころかR側の名前空間にアクセスしてオブジェクトを引っ張ってこれます。

````
`r ''````{python}
py_iris = r.iris
py_iris = pd.DataFrame(py_iris)

py_iris.head(3)
`r ''````
````


```{python, echo=F}
py_iris=r.iris
py_iris=pd.DataFrame(py_iris)

py_iris.head(3)
```

R側からもPythonの名前空間を呼び出してオブジェクトを取り扱えます。

```{r}
pyenv <- import_main()
dat <- pyenv$df

dat %>% head
```


### 例えば乱数を共有する

一様乱数がシェアできればどんな累積密度分布に対しても対応する乱数を生成できる。

単にseed値を同一にしただけではRとpythonで生成される乱数は異なるので、うまく受け渡してあげる。

#### Rで乱数生成

```{r}
seed <- 71
N <- 10

set.seed(seed)
runif(N, 0, 1)
```

#### Python上でPyperを使ってRによる乱数生成を実行

```{python, eval = F}
import pyper

r = pyper.R()
r("set.seed(71); unif_r <- runif(10, 0, 1)")

result = r.get("unif_r")
result
```

```{python, include = F}
import pyper

r = pyper.R()
r("set.seed(71); unif_r <- runif(10, 0, 1)")

result = r.get("unif_r")
```

```{python, echo = F}
result
```

#### Python上で乱数生成


```{python}
import random
seed = int(r.seed)
N = int(r.N)

random.seed(seed)

unif_rd = np.array([random.random() for i in range(N)])

unif_rd
```

#### R上でreticulateを使ってPythonの乱数生成を実行

```{r}
library(reticulate)
rd <- import("random")

rd$seed(seed)
map_dbl(1:N, ~rd$random())
```

Pyperを使ってPython上でRを動かすより、reticulateを使ってR上でPythonを動かす方が何かと楽。

## まとめ

・`use_python`でPythonインタープリタのPathを通そう。\
・`source_python`でPythonで定義された関数を読み込めるよ。\
・型注意な。\
・R上で、`reticulate::import()`を使うとPythonパッケージも読み込める。\
・Rmdだと、chunk内でPython打てるんだよ。\
・chunk超えてオブジェクトも受け渡せるし、Rからも呼べる。\
・プレビューも出る!!

## refs

・[R MarkdownでPythonを書こう](https://rpubs.com/nakamichi_/rmd-python)

### 実行環境

```{r, echo =F}
sessioninfo::os_name()
sessioninfo::package_info(c("opencv", "EBImage", "magick", "imager", "reticulate", "tidyverse", "ggplot2", "purrr", "tidyr", "dplyr"), dependencies = FALSE)
```

```{python, echo = F}
from sinfo import sinfo
sinfo()
```
